extends c
#TEMPLATE
snippet frase "xd"
	/*
	   1.- "No bajes tus sueños a la altura de tus capacidades aparentes, sino haz que
	         estas se eleven hasta llegar a la altura de tus sueños."

	   2.- "Todo mundo quiere ir al cielo pero nadie quiere morir."

	   3.- "Tarde o temprano la disciplina supera al talento."
	   
	   4.- "Get A Life!!!!!"

	   5.- "La suerte es donde confluyen la preparación y la oportunidad." -Séneca
	*/
snippet hora "hora" b
	/*
	 * Author: Jorge_Slime
	 * Created: `strftime('%d-%m-%Y')`
	 * Time: `strftime('%H:%M:%S')`
	*/
	$1
snippet ordered_set 
	#include <ext/pb_ds/tree_policy.hpp>
	#include <ext/pb_ds/assoc_container.hpp>
	using namespace __gnu_pbds
	template<typename T>  using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
snippet raiz 
	template <typename T> inline T sqrt_(T n){
    	T x=sqrtl(n)+1;
    	while(x*x>n) x--;
    	return x;
	}
snippet UTILS_DEFINE "definiciones utiles y rapidas"
	//defines utiles 
	#define MIN(v)                                           *min_element(all(v))
	#define MAX(v)                                           *max_element(all(v))
	#define LB(c, x)              distance((c).begin(), lower_bound(all(c), (x)))
	#define UB(c, x)              distance((c).begin(), upper_bound(all(c), (x)))
	#define UNIQUE(x) \
	            sort(all(x)), x.erase(unique(all(x)), x.end()), x.shrink_to_fit()
snippet FOR "for ultra premiun " b 
	//multiparameter for 
	#define                                  FOR1(a) for (auto _ = 0; _ < a; ++_)
	#define                               FOR2(i, a) for (auto i = 0; i < a; ++i)
	#define                            FOR3(i, a, b) for (auto i = a; i < b; ++i)
	#define                      FOR4(i, a, b, c) for (auto i = a; i < b; i+=(c))
	#define                           FOR1_R(a) for (auto i = (a)-1; i >= 0; --i)
	#define                        FOR2_R(i, a) for (auto i = (a)-1; i >= 0; --i)
	#define                     FOR3_R(i, a, b) for (auto i = (b)-1; i >= a; --i)
	#define                                       overload4(a, b, c, d, e, ...) e
	#define                                          overload3(a, b, c, d, ...) d
	#define  forn(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)
	#define  rfor(...) overload3(__VA_ARGS__, FOR3_R, FOR2_R, FOR1_R)(__VA_ARGS__)
snippet BITS 
	//Bits utils
	#define lsb_(x) __builtin_ctz(x) //bit menos sig
	#define lsbll_(x) __builtin_ctzll(x)
	#define msb_(x) 31-__builtin_clz(x) //bit mas significativo
	#define msbll_(x) 63-__builtin_clzll(x)
snippet INF 
	//multitype INF
	using ll=long long;
	template <class T> constexpr T INF = 0;
	template <> constexpr int INF<int> = 1'000'000'000;
	template <> constexpr ll INF<ll> = ll(INF<int>) * INF<int> * 2;
	template <> constexpr unsigned long long INF<unsigned long long> = INF<ll>;
	template <> constexpr __int128 INF<__int128> = __int128(INF<ll>) * INF<ll>;
	template <> constexpr double INF<double> = INF<ll>;
	template <> constexpr long double INF<long double> = INF<ll>;
snippet INF20 
	//multitype INF c++ 20
	using u64 = uint64_t;
	using i128 = __int128_t;
	template <class T> constexpr T INF = 0;
	template <> constexpr i32 INF<i32> = 1'000'000'000;
	template <> constexpr i64 INF<i64> = i64(INF<i32>) * INF<i32> * 2;
	template <> constexpr u64 INF<u64> = INF<i64>;
	template <> constexpr i128 INF<i128> = i128(INF<i64>) * INF<i64>;
	template <> constexpr double INF<double> = INF<i64>;
	template <> constexpr long double INF<long double> = INF<i64>;
snippet redondeo
	template <typename T>
	T floor(T a, T b) {
	  return a / b - (a % b && (a ^ b) < 0);
	}
	//redondeo a techo 
	template <typename T>
	T ceil(T x, T y) {
	  return floor(x + y - 1, y);
	}
snippet debu 
	//==========-Debugguer-=============
	#ifdef SLIME
		#include "/home/jorge/slime_debug.h"
	#else
		#define deb(...)
		#define debn(args...)
		#define TIME
		#define LINE
		#define XD
	#endif
	//=================================
snippet DEBUGGER11
	//DEBUGGER ULTRA PREMIUM XD
	template <class c>
	struct rge {
	    c b, e;
	};
	template <class c>
	rge<c> range(c i, c j) {
	    return rge<c>{i, j};
	}
	template <class c>
	auto dud(c* x) -> decltype(std::cerr << *x, 0) {
	    return 0;
	}
	template <class c>
	char dud(...) {
	    return 0;
	}
	struct debug {
	#ifdef LOCAL
	    ~debug() {
	        std::cerr << std::endl;
	    }
	    template <class c>
	    typename std::enable_if<sizeof(dud<c>(0)) != 1, debug&>::type operator<<(c i) {
	        std::cerr << std::boolalpha << i;
	        return *this;
	    }
	    template <class c>
	    typename std::enable_if<sizeof(dud<c>(0)) == 1, debug&>::type operator<<(c i) {
	        return *this << range(std::begin(i), std::end(i));
	    }
	    template <class b, class c>
	    debug& operator<<(std::pair<b, c> d) {
	        return *this << "(" << d.first << ", " << d.second << ")";
	    }
	    template <class c>
	    debug& operator<<(rge<c> d) {
	        *this << "[";
	        for (auto it = d.b; it != d.e; ++it) {
	            *this << ", " + 2 * (it == d.b) << *it;
	        }
	        return *this << "]";
	    }
	#else
	    template <class c>
	    debug& operator<<(const c&) {
	        return *this;
	    }
	#endif
	};
	#define _(arg1) " [" << #arg1 ": " << (arg1) << "] "
	#define _l(...) " ["<<" ["<<__LINE__<<"] "<< #__VA_ARGS__ ": " << (__VA_ARGS__) << "] "
	#define debu debug()
	#define deb_(...) debug() << _(__VA_ARGS__)
	#define debl(...) debug() << _l(__VA_ARGS__)
	//=====================================================================
	$1
snippet PRINT	
	//simple print 
	template <class Head, class... Tail>
	inline void print(Head &&head, Tail &&...tail) {
	    cout << head;
	    if constexpr (sizeof...(tail) == 0) cout << '\n';
	    else {cout << ' ';print(std::forward<Tail>(tail)...);}
	}
	//print Vector
	template<typename T> inline void print(vector<T>&v){for(int i=0;i<(int)v.size();i++) cout<<v[i]<<" \n"[i==(int)v.size()-1];}
	template<typename T> inline void print(vector<T>&v,int n){for(int i=0;i<n;i++) cout<<v[i]<<" \n"[i==(int)v.size()-1];}
	template<typename T> inline void print(T v[],int n){for(int i=0;i<n;i++) cout<<v[i]<<" \n"[i==n-1];}
# SIMPLE TEMPLATE
snippet basic
	//THINK ONCE, CODE TWICE
	#include "bits/stdc++.h"
	using namespace std; 

	int main(){
		$1
		return 0;
	}
snippet basic20
	//THINK ONCE, CODE TWICE  "写之前要思考"
	#include <iostream> 
	#include <cstdint>
	using i32=std::int32_t;
	using i64=std::int64_t;
	template <class T> auto read() -> T {
	    auto v = T();
	    std::cin >> v;
	    return v;
	}
	auto main()->signed{
		$1
	    return 0; 
	}
snippet simple
	//THINK ONCE, CODE TWICE   "写之前要思考"
	#include "bits/stdc++.h"
	#define LN '\n'
	using namespace std;

	int main(){
		ios_base::sync_with_stdio(0);
		cin.tie(0);
		cout.tie(0);
		$1
		return 0;
	}
snippet simple11 
	//THINK ONCE, CODE TWICE   "写之前要思考"
	#include <bits/stdc++.h>
	using namespace std;
	
	#define sz(x)     ((int)x.size())
	#define all(x)    begin(x),end(x)
	#define rall(x) rbegin(x),rend(x)
	#define pb              push_back
	#define eb           emplace_back
	#define V                  vector
	#define LN                   '\n'
	#define turbo_PA ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)
	typedef long long ll;
	  
	void solve(){
	    $1  
	}
	int main(){turbo_PA;
	    ll TT=1; 
	    //cin>>TT;
	    for(;TT--;) solve();
	    return 0;
	}
snippet simple17
	//THINK ONCE, CODE TWICE   "写之前要思考"
	#include <bits/stdc++.h>
	using namespace std;
	
	#define sz(x)     ((int)x.size())
	#define all(x)    begin(x),end(x)
	#define rall(x) rbegin(x),rend(x)
	#define pb      		push_back
	#define eb           emplace_back
	#define LN                   '\n'
	
	using ll=int64_t;
	template<typename T> using V=vector<T>;
	
	void solve(){
		$1  
	}
	auto main()->int32_t{
	    cin.tie(nullptr)->sync_with_stdio(0);
	    cin.exceptions(std::ios::failbit | std::ios::badbit);
	    cout.tie(nullptr)->sync_with_stdio(0);
	    ll t=1; 
	    //cin>>t;
	    for(;t--;) solve();
	    return 0;
	}
snippet simple20 
	//THINK ONCE, CODE TWICE   "写之前要思考"
	#include "bits/stdc++.h"
	using namespace std;
	
	#define sz(x)       (int)x.size()
	#define all(x)    begin(x),end(x)
	#define rall(x) rbegin(x),rend(x)
	#define eb           emplace_back
	#define LN                   '\n'
	
	using i32=int32_t;
	using i64=int64_t;
	template<typename T> using V=vector<T>;
	
	auto solve()->void{
	    $1
	}
	auto main()->signed{
	    cin.tie(nullptr)->sync_with_stdio(0);
	    cin.exceptions(std::ios::failbit | std::ios::badbit);
	    cout.tie(nullptr)->sync_with_stdio(0);
	    i32 t=1; 
	    //cin>>t;
	    for(;t--;) solve();
	    return 0;
	}
#COMPLETOS
snippet Z11
	//THINK ONCE, CODE TWICE  "写之前要思考"
	
	//C++11... solve line -> 67
	#include <bits/stdc++.h>
	
	using namespace std;
	
	#define LN                                             		             '\n'
	#define sz(x)                                              	   (int) x.size()
	#define all(x)                                           	 begin(x), end(x)
	#define rall(x)                                        	   rbegin(x), rend(x)
	
	#define                                  FOR1(a) for (auto _ = 0; _ < a; ++_)
	#define                               FOR2(i, a) for (auto i = 0; i < a; ++i)
	#define                            FOR3(i, a, b) for (auto i = a; i < b; ++i)
	#define                      FOR4(i, a, b, c) for (auto i = a; i < b; i+=(c))
	#define                           FOR1_R(a) for (auto i = (a)-1; i >= 0; --i)
	#define                        FOR2_R(i, a) for (auto i = (a)-1; i >= 0; --i)
	#define                     FOR3_R(i, a, b) for (auto i = (b)-1; i >= a; --i)
	#define                                       overload4(a, b, c, d, e, ...) e
	#define                                          overload3(a, b, c, d, ...) d
	#define  forn(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)
	#define  rfor(...) overload3(__VA_ARGS__, FOR3_R, FOR2_R, FOR1_R)(__VA_ARGS__)
	#define  mem(a, h)                                  memset(a, (h), sizeof(a))
	
	#define pb                                                          push_back
	#define eb                                                       emplace_back
	#define F                                                               first
	#define S                                                              second
	#define V                                                              vector
	/*==========================================================================================*/
	typedef                                                         long long ll;
	typedef                                               unsigned long long ull;
	typedef                                                            double dd;
	typedef                                                     pair<int,int> ii;
	typedef                                                       vector<ii> vii;
	typedef                                                       vector<int> vi;
	typedef                                                       vector<ll> vil;
	/*==========================================================================================*/
	//Short funcions
	template <typename T> inline T max_(T a, T b) { return (a > b) ? a : b;}
	template <typename T> inline T min_(T a, T b) { return (a < b) ? a : b;}
	template <typename T> inline T abs_(T x) { return (x < 0) ? -x : x;}
	template <typename T> inline T mcm_(T a,T b){return a*b/__gcd(a,b);}
	
	
	/*==========================================================================================*/
	//Constants
	constexpr int dx[]={-1, 0, 1, 0},dy[]={0, 1, 0, -1};
	constexpr int inf=INT32_MAX;
	constexpr ll INF=INT64_MAX; //0x3f3f3f3f3f3f3f3f;
	constexpr int MOD=1000000007;
	constexpr int MOD99=998244353;
	/*==========================================================================================*/
	
	// ===============SOLUTION======================================
	
	inline void XD();
	
	int main(){
	   ios_base::sync_with_stdio(0);
	   cin.tie(0);
	   cout.tie(0);
	   XD();
	   return 0;
	} 
	
	void solve(){
		$1
	}
	
	inline void XD(){
	    ll TT=1;
	    //cin>>TT;
	    //ll TestCase(0);
	    for(;TT--;){
	        //TestCase++;
	        //cout<<"Case #"<<TestCase<<":"<<LN;
	        solve();
	    }
	}
	/*
	   -"No bajes tus sueños a la altura de tus capacidades aparentes, sino haz que
	     estas se eleven hasta llegar a la altura de tus sueños."
	   -"Todo mundo quiere ir al cielo pero nadie quiere morir."
	   -"Tarde o temprano la disciplina supera al talento."
	   -"Get A Life!!!!!"
	*/

snippet Z17 
	//THINK ONCE, CODE TWICE  "写之前要思考" 
	// template for c++17 Onwars | SOLVE_LINE-> 180
	#if !defined(ENABLE_DEBUG) && !defined(__clang__)
	#pragma GCC optimize("Ofast,unroll-loops")
	//#pragma GCC target("avx2,bmi2") // ._. It does not work in Arch Linux :')
	#endif
	
	#include <bits/stdc++.h>
	#include <ext/pb_ds/tree_policy.hpp>
	#include <ext/pb_ds/assoc_container.hpp>
	
	using namespace std;
	using namespace __gnu_pbds;
	
	#define LN                                                               '\n'
	#define sz(x)                                                  (int) x.size()
	#define all(x)                                               begin(x), end(x)
	#define rall(x)                                            rbegin(x), rend(x)
	#define in(v)                                           forn(i,sz(v)) cin>>i;
	#define ou(v)                                  forn(i,sz(v)) cout<<v[i]<<" ";
	#define DBG(x)                                                           (#x)
	#define mem(a, h)                                   memset(a, (h), sizeof(a))
	#define pb                                                          push_back
	#define eb                                                       emplace_back
	#define F                                                               first
	#define S                                                              second
	#define MIN(v)                                           *min_element(all(v))
	#define MAX(v)                                           *max_element(all(v))
	#define LB(c, x)              distance((c).begin(), lower_bound(all(c), (x)))
	#define UB(c, x)              distance((c).begin(), upper_bound(all(c), (x)))
	#define UNIQUE(x) \
	            sort(all(x)), x.erase(unique(all(x)), x.end()), x.shrink_to_fit()
	#define                                  FOR1(a) for (auto _ = 0; _ < a; ++_)
	#define                               FOR2(i, a) for (auto i = 0; i < a; ++i)
	#define                            FOR3(i, a, b) for (auto i = a; i < b; ++i)
	#define                      FOR4(i, a, b, c) for (auto i = a; i < b; i+=(c))
	#define                           FOR1_R(a) for (auto i = (a)-1; i >= 0; --i)
	#define                        FOR2_R(i, a) for (auto i = (a)-1; i >= 0; --i)
	#define                     FOR3_R(i, a, b) for (auto i = (b)-1; i >= a; --i)
	#define                                       overload4(a, b, c, d, e, ...) e
	#define                                          overload3(a, b, c, d, ...) d
	#define forn(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)
	#define rfor(...) overload3(__VA_ARGS__, FOR3_R, FOR2_R, FOR1_R)(__VA_ARGS__)
	#define INT(...) \
	  int __VA_ARGS__; \
	  rd(__VA_ARGS__)
	#define LL(...) \
	  ll __VA_ARGS__; \
	  rd(__VA_ARGS__)
	#define vec(type, name, size) \
	  vector<type> name(size);    \
	  cin>>v;                     \
	  sort(all(v));
	/*==========================================================================================*/
	template<typename T>  using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
	template<typename T>                       using  pq = priority_queue<T>;
	template<typename T>  using pqg = priority_queue<T,vector<T>,greater<T>>;
	template<typename T>                       using             V=vector<T>;
	template<typename AA,typename BB>          using UM=unordered_map<AA,BB>;
	template<typename T>                       using     US=unordered_set<T>;
	template<typename AA,typename BB>          using            M=map<AA,BB>;
	template<typename AA,typename BB>          using           P=pair<AA,BB>;
	using                                                  uint=unsigned int;
	using                                                       ll=long long;
	using                                             ull=unsigned long long;
	using                                                          dd=double;
	using                                                    ldd=long double;
	using                                                      i128=__int128;
	using                                                    f128=__float128;
	using                                             u128=unsigned __int128;
	/*==========================================================================================*/
	//Short funcions
	template <typename T> inline T max_(T a, T b) { return (a > b) ? a : b;}
	template <typename T> inline T min_(T a, T b) { return (a < b) ? a : b;}
	template <typename T> inline T abs_(T x) { return (x < 0) ? -x : x;}
	template <typename T> inline T mcm_(T a,T b){return a*b/__gcd(a,b);}
	// cin->vector
	template <typename T>
	istream &operator>>(istream &is, vector<T> &v) {
	  for (T &in : v) is >> in;
	  return is;
	}
	// cin->vector(pair)
	template <typename T>
	istream &operator>>(istream &is, vector<pair<T, T>> &v) {
	  for (auto &in : v) is >> in.first >> in.second;
	  return is;
	}
	template <class T, class S>
	inline bool chmax(T &a, const S &b) {
	  return (a < b ? a = b, 1 : 0);
	}
	template <class T, class S>
	inline bool chmin(T &a, const S &b) {
	  return (a > b ? a = b, 1 : 0);
	}
	//#if __cplusplus >= 201703L
	// -> C++17 Onwars... 
	template <class... T>
	void rd(T &...a) {
	  (cin>> ... >> a);
	}
	//Generate ramdomic numbers c++17 onwers
	//inline mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
	//#endif
	// DEGUGGER PREMIUM XD 
	template <class Head, class... Tail>
	inline void deb(Head &&head, Tail &&...tail) {
	    cerr << "DBG: " << head;
	    if constexpr (sizeof...(tail) == 0) {
	        cerr << '\n';
	    } else {
	        cerr << ' ';
	        deb(forward<Tail>(tail)...);
	    }
	}
	template<typename T> inline void deb(V<T>&v){ cerr<<DBG(v)<<"-> ";for(auto&&i:v) cerr<<i<<" ";cerr<<LN;}
	template<typename T> inline void deb(V<T>&v,int n){ cerr<<DBG(v)<<"-> ";forn(i,n) cerr<<v[i]<<" ";cerr<<LN;}
	template<typename T> inline void deb(T v[],int n){ cerr<<DBG(v)<<"-> ";forn(i,n) cerr<<v[i]<<" ";cerr<<LN;}
	//simple print 
	template <class Head, class... Tail>
	inline void print(Head &&head, Tail &&...tail) {
	    cout << head;
	    if constexpr (sizeof...(tail) == 0) {
	        cout << '\n';
	    } else {
	        cout << ' ';
	        print(forward<Tail>(tail)...);
	    }
	}
	//print Vector
	template<typename T> inline void print(V<T>&v){ forn(i,sz(v)) cout<<v[i]<<" "; cout<<LN;}
	template<typename T> inline void print(V<T>&v,int n){forn(i,n) cout<<v[i]<<" ";cout<<LN;}
	template<typename T> inline void print(T v[],int n){forn(i,n) cout<<v[i]<<" ";cout<<LN;}
	inline void YES(bool t = 1) { cout<<(t ? "YES" : "NO")<<LN; }
	inline void NO(bool t = 1) { YES(!t); }
	inline void Yes(bool t = 1) { cout<<(t ? "Yes" : "No")<<LN; }
	inline void No(bool t = 1) { Yes(!t); }
	inline void yes(bool t = 1) { cout<<(t ? "yes" : "no")<<LN; }
	inline void no(bool t = 1) { yes(!t); }
	/*==========================================================================================*/
	//Constants
	const int dx[]={-1, 0, 1, 0},dy[]={0, 1, 0, -1};
	const int MOD=1000000007;
	const int MOD99=998244353;
	template <class T> constexpr T INF = 0;
	template <> constexpr int INF<int> = 1'000'000'000;
	template <> constexpr ll INF<ll> = ll(INF<int>) * INF<int> * 2;
	template <> constexpr ull INF<ull> = INF<ll>;
	template <> constexpr i128 INF<i128> = i128(INF<ll>) * INF<ll>;
	template <> constexpr double INF<double> = INF<ll>;
	template <> constexpr long double INF<long double> = INF<ll>;
	/*==========================================================================================*/
	
	// ===============SOLUTION======================================
	inline void XD();
	
	auto main()->signed{//turbo_PA;
		ios_base::sync_with_stdio(0);
		cin.tie();
		cout.tie(0);
	   	XD();
	   	return 0;
	} 
	
	void solve(){
		$1
	}
	
	inline void XD(){
	    ll TT=1;
	    //cin>>TT;
	    //ll TestCase(0);
	    for(;TT--;){
	        //TestCase++;
	        //cout<<"Case #"<<TestCase<<":"<<LN;
	        solve();
	    }
	}
	/*
	   -"No bajes tus sueños a la altura de tus capacidades aparentes, sino haz que
	     estas se eleven hasta llegar a la altura de tus sueños."
	   -"Todo mundo quiere ir al cielo pero nadie quiere morir."
	   -"Tarde o temprano la disciplina supera al talento."
	   -"Get A Life!!!!!"
	*/

snippet Z
	//THINK ONCE, CODE TWICE "写之前要思考"
	// template for c++17 Onwars 
	#if !defined(ENABLE_DEBUG) && !defined(__clang__) // for more check this blog https://codeforces.com/blog/entry/96344
	#pragma GCC optimize("Ofast,unroll-loops")
	//#pragma GCC target("avx2,bmi2") // ._. It does not work in Arch Linux :')
	#endif
	
	#include <bits/stdc++.h>
	#include <ext/pb_ds/tree_policy.hpp>
	#include <ext/pb_ds/assoc_container.hpp>
	
	using namespace std;
	using namespace __gnu_pbds;
	
	#define LN                                                               '\n'
	#define sz(x)                                                  (int) x.size()
	#define all(x)                                               begin(x), end(x)
	#define rall(x)                                            rbegin(x), rend(x)
	#define mem(a, h)                                   memset(a, (h), sizeof(a))
	#define DBG(x)                                                           (#x)
	#define pb                                                          push_back
	#define eb                                                       emplace_back
	#define F                                                               first
	#define S                                                              second
	#define MIN(v)                                           *min_element(all(v))
	#define MAX(v)                                           *max_element(all(v))
	#define LB(c, x)              distance((c).begin(), lower_bound(all(c), (x)))
	#define UB(c, x)              distance((c).begin(), upper_bound(all(c), (x)))
	#define UNIQUE(x) \
	            sort(all(x)), x.erase(unique(all(x)), x.end()), x.shrink_to_fit()
	#define                                  FOR1(a) for (auto _ = 0; _ < a; ++_) //for more check this blog -> https://trap.jp/post/1224/
	#define                               FOR2(i, a) for (auto i = 0; i < a; ++i)
	#define                            FOR3(i, a, b) for (auto i = a; i < b; ++i)
	#define                      FOR4(i, a, b, c) for (auto i = a; i < b; i+=(c))
	#define                           FOR1_R(a) for (auto i = (a)-1; i >= 0; --i)
	#define                        FOR2_R(i, a) for (auto i = (a)-1; i >= 0; --i)
	#define                     FOR3_R(i, a, b) for (auto i = (b)-1; i >= a; --i)
	#define                                       overload4(a, b, c, d, e, ...) e
	#define                                          overload3(a, b, c, d, ...) d
	#define forn(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)
	#define rfor(...) overload3(__VA_ARGS__, FOR3_R, FOR2_R, FOR1_R)(__VA_ARGS__)
	#define INT(...) \
		int __VA_ARGS__; \
	  	in(__VA_ARGS__)
	#define LL(...) \
	  	ll __VA_ARGS__; \
	  	in(__VA_ARGS__)
	#define STR(...) \
  		string __VA_ARGS__; \
  		in(__VA_ARGS__)
	#define vec(type, name, size) \
	  	vector<type> name(size);    \
	  	in(name);                   \
	  	sort(all(v));
	/*==========================================================================================*/
	template<typename T>  using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
	template<typename T>                       using  pq = priority_queue<T>;
	template<typename T>  using pqg = priority_queue<T,vector<T>,greater<T>>;
	template<typename T>                       using             V=vector<T>;
	template<typename AA,typename BB>          using UM=unordered_map<AA,BB>;
	template<typename T>                       using     US=unordered_set<T>;
	template<typename AA,typename BB>          using            M=map<AA,BB>;
	template<typename AA,typename BB>          using           P=pair<AA,BB>;
	using                                                  uint=unsigned int;
	using                                                       ll=long long;
	using                                             ull=unsigned long long;
	using                                                          dd=double;
	using                                                    ldd=long double;
	using                                                      i128=__int128;
	using                                                    f128=__float128;
	using                                             u128=unsigned __int128;
	/*==========================================================================================*/
	//Short funcions
	template <typename T> inline T max_(T a, T b) { return (a > b) ? a : b;}
	template <typename T> inline T min_(T a, T b) { return (a < b) ? a : b;}
	template <typename T> inline T abs_(T x) { return (x < 0) ? -x : x;}
	template <typename T> inline T mcm_(T a,T b){return a*b/__gcd(a,b);}
	
	template <class T, class S>
	inline bool chmax(T &a, const S &b) {
	  return (a < b ? a = b, 1 : 0);
	}
	template <class T, class S>
	inline bool chmin(T &a, const S &b) {
	  return (a > b ? a = b, 1 : 0);
	}
	// cin->vector
	template <typename T>
	istream &operator>>(istream &is, vector<T> &v) {
	  for (T &in : v) is >> in;
	  return is;
	}
	// cin->vector(pair)
	template <typename T>
	istream &operator>>(istream &is, vector<pair<T, T>> &v) {
	  for (auto &in : v) is >> in.first >> in.second;
	  return is;
	}
	//Generate ramdomic numbers c++17 onwers
	//inline mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
	//#endif
	/*==========================================================================================*/
	//Constants
	const int dx[]={-1, 0, 1, 0},dy[]={0, 1, 0, -1};
	const int MOD=1000000007;
	const int MOD99=998244353;
	template <class T> constexpr T INF = 0;
	template <> constexpr int INF<int> = 1'000'000'000;
	template <> constexpr ll INF<ll> = ll(INF<int>) * INF<int> * 2;
	template <> constexpr ull INF<ull> = INF<ll>;
	template <> constexpr i128 INF<i128> = i128(INF<ll>) * INF<ll>;
	template <> constexpr double INF<double> = INF<ll>;
	template <> constexpr long double INF<long double> = INF<ll>;
	/*==========================================================================================*/
	// DEGUGGER PREMIUM XD 
	template <class Head, class... Tail>
	inline void deb(Head &&head, Tail &&...tail) {
	    cerr << "DBG: " << head;
	    if constexpr (sizeof...(tail) == 0) {
	        cerr << '\n';
	    } else {
	        cerr << ' ';
	        deb(forward<Tail>(tail)...);
	    }
	}
	template<typename T> inline void deb(V<T>&v){ cerr<<DBG(v)<<"-> ";for(auto&&i:v) cerr<<i<<" ";cerr<<LN;}
	template<typename T> inline void deb(V<T>&v,int n){ cerr<<DBG(v)<<"-> ";forn(i,n) cerr<<v[i]<<" ";cerr<<LN;}
	template<typename T> inline void deb(T v[],int n){ cerr<<DBG(v)<<"-> ";forn(i,n) cerr<<v[i]<<" ";cerr<<LN;}
	//simple print 
	template <class Head, class... Tail>
	inline void print_(Head &&head, Tail &&...tail) {
	    cout << head;
	    if constexpr (sizeof...(tail) == 0) {
	        cout << '\n';
	    } else {
	        cout << ' ';
	        print_(forward<Tail>(tail)...);
	    }
	}
	//print Vector or array
	template<typename T> inline void print_(V<T>&v){ forn(i,sz(v)) cout<<v[i]<<" "; cout<<LN;}
	template<typename T> inline void print_(V<T>&v,int n){forn(i,n) cout<<v[i]<<" ";cout<<LN;}
	template<typename T> inline void print_(T v[],int n){forn(i,n) cout<<v[i]<<" ";cout<<LN;}
	//fastIO ULTRA PREMIUM XD-> ONLY FILES ENTRY
	namespace fastio {  //for more check this blog https://judge.yosupo.jp/submission/21623
	static constexpr uint32_t SZ = 1 << 17;
	char ibuf[SZ];
	char obuf[SZ];
	char out[100];
	// pointer of ibuf, obuf
	uint32_t pil = 0, pir = 0, por = 0;
	struct Pre {
	  char num[10000][4];
	  constexpr Pre() : num() {
	    for (int i = 0; i < 10000; i++) {
	      int n = i;
	      for (int j = 3; j >= 0; j--) {
	        num[i][j] = n % 10 | '0';
	        n /= 10;
	      }
	    }
	  }
	} constexpr pre;
	 
	inline void load() {
	  memcpy(ibuf, ibuf + pil, pir - pil);
	  pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);
	  pil = 0;
	  if (pir < SZ) ibuf[pir++] = '\n';
	}
	inline void flush() {
	  fwrite(obuf, 1, por, stdout);
	  por = 0;
	}
	 
	void rd(char &c) {
	  do {
	    if (pil + 1 > pir) load();
	    c = ibuf[pil++];
	  } while (isspace(c));
	}
	 
	void rd(string &x) {
	  x.clear();
	  char c;
	  do {
	    if (pil + 1 > pir) load();
	    c = ibuf[pil++];
	  } while (isspace(c));
	  do {
	    x += c;
	    if (pil == pir) load();
	    c = ibuf[pil++];
	  } while (!isspace(c));
	}
	 
	template <typename T>
	void rd_real(T &x) {
	  string s;
	  rd(s);
	  x = stod(s);
	}
	 
	template <typename T>
	void rd_integer(T &x) {
	  if (pil + 100 > pir) load();
	  char c;
	  do
	    c = ibuf[pil++];
	  while (c < '-');
	  bool minus = 0;
	  if constexpr (is_signed<T>::value || is_same_v<T, i128>) {
	    if (c == '-') { minus = 1, c = ibuf[pil++]; }
	  }
	  x = 0;
	  while ('0' <= c) { x = x * 10 + (c & 15), c = ibuf[pil++]; }
	  if constexpr (is_signed<T>::value || is_same_v<T, i128>) {
	    if (minus) x = -x;
	  }
	}
	 
	void rd(int &x) { rd_integer(x); }
	void rd(ll &x) { rd_integer(x); }
	void rd(i128 &x) { rd_integer(x); }
	void rd(uint &x) { rd_integer(x); }
	void rd(ull &x) { rd_integer(x); }
	void rd(u128 &x) { rd_integer(x); }
	void rd(double &x) { rd_real(x); }
	void rd(long double &x) { rd_real(x); }
	void rd(f128 &x) { rd_real(x); }
	 
	template <class T, class U>
	void rd(pair<T, U> &p) {
	  return rd(p.first), rd(p.second);
	}
	template <size_t N = 0, typename T>
	void rd_tuple(T &t) {
	  if constexpr (N < std::tuple_size<T>::value) {
	    auto &x = std::get<N>(t);
	    rd(x);
	    rd_tuple<N + 1>(t);
	  }
	}
	template <class... T>
	void rd(tuple<T...> &tpl) {
	  rd_tuple(tpl);
	}
	 
	template <size_t N = 0, typename T>
	void rd(array<T, N> &x) {
	  for (auto &d: x) rd(d);
	}
	template <class T>
	void rd(V<T> &x) {
	  for (auto &d: x) rd(d);
	}
	 
	void in() {}
	template <class H, class... T>
	void in(H &h, T &... t) {
	  rd(h), in(t...);
	}
	 
	void wt(const char c) {
	  if (por == SZ) flush();
	  obuf[por++] = c;
	}
	void wt(const string s) {
	  for (char c: s) wt(c);
	}
	void wt(const char *s) {
	  size_t len = strlen(s);
	  for (size_t i = 0; i < len; i++) wt(s[i]);
	}
	 
	template <typename T>
	void wt_integer(T x) {
	  if (por > SZ - 100) flush();
	  if (x < 0) { obuf[por++] = '-', x = -x; }
	  int outi;
	  for (outi = 96; x >= 10000; outi -= 4) {
	    memcpy(out + outi, pre.num[x % 10000], 4);
	    x /= 10000;
	  }
	  if (x >= 1000) {
	    memcpy(obuf + por, pre.num[x], 4);
	    por += 4;
	  } else if (x >= 100) {
	    memcpy(obuf + por, pre.num[x] + 1, 3);
	    por += 3;
	  } else if (x >= 10) {
	    int q = (x * 103) >> 10;
	    obuf[por] = q | '0';
	    obuf[por + 1] = (x - q * 10) | '0';
	    por += 2;
	  } else
	    obuf[por++] = x | '0';
	  memcpy(obuf + por, out + outi + 4, 96 - outi);
	  por += 96 - outi;
	}
	template <typename T>
	void wt_real(T x) {
	  ostringstream oss;
	  oss << fixed << setprecision(15) << double(x);
	  string s = oss.str();
	  wt(s);
	}
	 
	inline void wt(int x) { wt_integer(x); }
	inline void wt(ll x) { wt_integer(x); }
	inline void wt(i128 x) { wt_integer(x); }
	inline void wt(uint x) { wt_integer(x); }
	inline void wt(ull x) { wt_integer(x); }
	inline void wt(u128 x) { wt_integer(x); }
	inline void wt(double x) { wt_real(x); }
	inline void wt(long double x) { wt_real(x); }
	inline void wt(f128 x) { wt_real(x); }
	 
	template <class T, class U>
	void wt(const pair<T, U> val) {
	  wt(val.first);
	  wt(' ');
	  wt(val.second);
	}
	
	template <size_t N = 0, typename T>
	void wt_tuple(const T t) {
	  if constexpr (N < std::tuple_size<T>::value) {
	    if constexpr (N > 0) { wt(' '); }
	    const auto x = std::get<N>(t);
	    wt(x);
	    wt_tuple<N + 1>(t);
	  }
	}
	template <class... T>
	void wt(tuple<T...> tpl) {
	  wt_tuple(tpl);
	}
	template <class T, size_t S>
	void wt(const array<T, S> val) {
	  auto n = val.size();
	  for (size_t i = 0; i < n; i++) {
	    if (i) wt(' ');
	    wt(val[i]);
	  }
	}
	template <class T>
	void wt(const vector<T> val) {
	  auto n = val.size();
	  for (size_t i = 0; i < n; i++) {
	    if (i) wt(' ');
	    wt(val[i]);
	  }
	}
	void print() { wt('\n'); }
	template <class Head, class... Tail>
	void print(Head &&head, Tail &&... tail) {
	  wt(head);
	  if (sizeof...(Tail)) wt(' ');
	  print(forward<Tail>(tail)...);
	}
	// gcc expansion. called automaticall after main.
	void __attribute__((destructor)) _d() { flush(); }
	} // namespace fastio
	using fastio::in;
	using fastio::print;
	using fastio::flush;
	//YES or NO
	inline void YES(bool t = 1) { print(t ? "YES" : "NO"); }
	inline void NO(bool t = 1) { YES(!t); }
	inline void Yes(bool t = 1) { print(t ? "Yes" : "No"); }
	inline void No(bool t = 1) { Yes(!t); }
	inline void yes(bool t = 1) { print(t ? "yes" : "no"); }
	inline void no(bool t = 1) { yes(!t); }
	// ===============SOLUTION======================================
	inline void XD();
	
	auto main()->signed{//turbo_PA;
	   cin.tie(nullptr)->sync_with_stdio(false);
	   cin.exceptions(std::ios::failbit | std::ios::badbit);
	   cout.tie(nullptr)->sync_with_stdio(false); 
	   XD();
	   return 0;
	} 
	
	void solve(){
	    $1
	}
	
	inline void XD(){
	    ll TT=1;
	    //in(TT);
	    //cin>>TT;
	    //ll TestCase(0);
	    for(;TT--;){
	        //TestCase++;
	        //cout<<"Case #"<<TestCase<<":"<<LN;
	        solve();
	    }
	}
	/*
	   -"No bajes tus sueños a la altura de tus capacidades aparentes, sino haz que
	     estas se eleven hasta llegar a la altura de tus sueños."
	   -"Todo mundo quiere ir al cielo pero nadie quiere morir."
	   -"Tarde o temprano la disciplina supera al talento."
	   -"Get A Life!!!!!"
	*/
snippet Z20 "wtf"   
	//THINK ONCE, CODE TWICE "写之前要思考"
	// template for c++20 Onwars 
	#pragma GCC optimize("O3,unroll-loops")
	#include "bits/stdc++.h"
	using namespace std; 
	
	#define                                  FOR1(a) for (auto _ = 0; _ < a; ++_) 
	#define                               FOR2(i, a) for (auto i = 0; i < a; ++i)
	#define                            FOR3(i, a, b) for (auto i = a; i < b; ++i)
	#define                      FOR4(i, a, b, c) for (auto i = a; i < b; i+=(c))
	#define                                       overload4(a, b, c, d, e, ...) e
	#define forn(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)
	#define LN                                                               '\n'
	#define sz(x)                                                  (int) x.size()
	#define all(x)                                               begin(x), end(x)
	#define rall(x)                                            rbegin(x), rend(x)
	#define eb                                                       emplace_back
	#define F                                                               first
	#define S                                                              second
	#define INT(...) \
	    i32 __VA_ARGS__; \
	    in(__VA_ARGS__)
	#define LL(...) \
	    i64 __VA_ARGS__; \
	    in(__VA_ARGS__)
	#define STR(...) \
	    string __VA_ARGS__; \
	    in(__VA_ARGS__)
	#define VEC(type, name, size) \
	    auto name=V<type>(size);   \
	    cin>>name;                  \
	    sort(all(v));
	/*==========================================================================================*/
	using                                                            i8 = int8_t;
	using                                                           u8 = uint8_t;
	using                                                          i16 = int16_t;
	using                                                         u16 = uint16_t;
	using                                                          i32 = int32_t;
	using                                                         u32 = uint32_t;
	using                                                          i64 = int64_t;
	using                                                         u64 = uint64_t;
	using                                                      i128 = __int128_t;
	using                                                     u128 = __uint128_t;
	using                                                         usize = size_t;
	template<typename T>                                       using V=vector<T>;
	template<typename AA,typename BB>              using UM=unordered_map<AA,BB>;
	/*==========================================================================================*/
	//==========-Debugguer-=============
	#ifdef SLIME
		#include "/home/jorge/slime_debug.h"
	#else
		#define deb(...)
		#define debn(args...)
		#define TIME
		#define LINE
		#define XD
	#endif
	//=================================
	//Short funcions
	template <typename T> inline T max_(T a, T b) { return (a > b) ? a : b;}
	template <typename T> inline T min_(T a, T b) { return (a < b) ? a : b;}
	template <typename T> inline T abs_(T x) { return (x < 0) ? -x : x;}
	template <typename T> inline T mcm_(T a,T b){return a*b/__gcd(a,b);}
	template <class T> auto read() -> T {
	  auto v = T();
	  cin >> v;
	  return v;
	}
	template<class... T>
	void in(T&... a){
	    (cin >> ... >> a);
	}
	// cin->vector
	template <typename T>
	istream &operator>>(istream &is, vector<T> &v) {
	  for (T &in : v) is >> in;
	  return is;
	}
	//Constants
	constexpr int dx[]={-1, 0, 1, 0},dy[]={0, 1, 0, -1};
	constexpr int MOD=1000000007;
	constexpr int MOD99=998244353;
	template <class T> constexpr T INF = 0;
	template <> constexpr i32 INF<i32> = 1'000'000'000;
	template <> constexpr i64 INF<i64> = i64(INF<i32>) * INF<i32> * 2;
	template <> constexpr u64 INF<u64> = INF<i64>;
	template <> constexpr i128 INF<i128> = i128(INF<i64>) * INF<i64>;
	template <> constexpr double INF<double> = INF<i64>;
	template <> constexpr long double INF<long double> = INF<i64>;
	//==========================================================================================
	//simple print 
	template <class Head, class... Tail>
	inline void print(Head &&head, Tail &&...tail) {
	    cout << head;
	    if constexpr (sizeof...(tail) == 0) cout << '\n';
	    else {cout << ' ';print(std::forward<Tail>(tail)...);}
	}
	//print Vector
	template<typename T> inline void print(vector<T>&v){for(int i=0;i<(int)v.size();i++) cout<<v[i]<<" \n"[i==(int)v.size()-1];}
	template<typename T> inline void print(vector<T>&v,int n){for(int i=0;i<n;i++) cout<<v[i]<<" \n"[i==(int)v.size()-1];}
	template<typename T> inline void print(T v[],int n){for(int i=0;i<n;i++) cout<<v[i]<<" \n"[i==n-1];}	//YES or NO
	inline void YES(bool t = 1) { print(t ? "YES" : "NO"); }
	inline void NO(bool t = 1) { YES(!t); }
	inline void Yes(bool t = 1) { print(t ? "Yes" : "No"); }
	inline void No(bool t = 1) { Yes(!t); }
	inline void yes(bool t = 1) { print(t ? "yes" : "no"); }
	inline void no(bool t = 1) { yes(!t); }
	// ===============================---SOLUTION---================================================

	inline auto init()->void{    
	}
	
	auto solve()->void{
	    $1
	}
	
	[[gnu::target("avx2")]] auto main()->signed{ //  haz flipao eh? 
	    cin.tie(nullptr)->sync_with_stdio(false);
	    init();
	    auto test_case = usize(1);
	    //test_case = read<usize>();
	    for(auto t=0;t!=test_case;++t){
	        solve();
			LINE
	    }
		TIME
		XD
	}
	/*
	   1.- "No bajes tus sueños a la altura de tus capacidades aparentes, sino haz que
	         estas se eleven hasta llegar a la altura de tus sueños."

	   2.- "Todo mundo quiere ir al cielo pero nadie quiere morir."

	   3.- "Tarde o temprano la disciplina supera al talento."
	   
	   4.- "Get A Life!!!!!"

	   5.- "La suerte es donde confluyen la preparación y la oportunidad." -Séneca
	*/
#TURBO
snippet turbo 
	std::ios_base::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
snippet turbo17
	std::cin.tie(nullptr)->sync_with_stdio(false);
	std::cin.exceptions(std::ios::failbit | std::ios::badbit);
	std::cout.tie(nullptr)->sync_with_stdio(false); 
snippet fastIO11
	static struct FastInput {
		static constexpr int BUF_SIZE = 1 << 20;
		char buf[BUF_SIZE];
		size_t chars_read = 0;
		size_t buf_pos = 0;
		FILE *in = stdin;
		char cur = 0;
		inline char get_char() {
			if (buf_pos >= chars_read) {
				chars_read = fread(buf, 1, BUF_SIZE, in);
				buf_pos = 0;
				buf[0] = (chars_read == 0 ? -1 : buf[0]);
			}
			return cur = buf[buf_pos++];
		}
	 
		inline void tie(std::nullptr_t) {}
	 
		inline explicit operator bool() {
			return cur != -1;
		}
	 
		inline static bool is_blank(char c) {
			return c <= ' ';
		}
	 
		inline bool skip_blanks() {
			while (is_blank(cur) && cur != -1) {
				get_char();
			}
			return cur != -1;
		}
	 
		inline FastInput& operator>>(char& c) {
			skip_blanks();
			c = cur;
			return *this;
		}
	 
		inline FastInput& operator>>(string& s) {
			if (skip_blanks()) {
				s.clear();
				do {
					s += cur;
				} while (!is_blank(get_char()));
			}
			return *this;
		}
	 
		template <typename T>
			inline FastInput& read_integer(T& n) {
				// unsafe, doesn't check that characters are actually digits
				n = 0;
				if (skip_blanks()) {
					int sign = +1;
					if (cur == '-') {
						sign = -1;
						get_char();
					}
					do {
						n += n + (n << 3) + cur - '0';
					} while (!is_blank(get_char()));
					n *= sign;
				}
				return *this;
			}
	 
		template <typename T>
			inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {
				return read_integer(n);
			}
	 
	#if !defined(_WIN32) || defined(_WIN64)
		inline FastInput& operator>>(__int128& n) {
			return read_integer(n);
		}
	#endif
		template <typename T>
			inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {
				// not sure if really fast, for compatibility only
				n = 0;
				if (skip_blanks()) {
					string s;
					(*this) >> s;
					sscanf(s.c_str(), "%lf", &n);
				}
				return *this;
			}
	} fast_input;
	#define cin fast_input
	
	//===================================CODE======================================================
	$1
snippet fastIO17 
	//fastIO ULTRA PREMIUM-> ONLY FILES ENTRY
	namespace fastio {  //for more check this blog https://judge.yosupo.jp/submission/21623
	static constexpr uint32_t SZ = 1 << 17;
	char ibuf[SZ];
	char obuf[SZ];
	char out[100];
	// pointer of ibuf, obuf
	uint32_t pil = 0, pir = 0, por = 0;
	struct Pre {
	  char num[10000][4];
	  constexpr Pre() : num() {
	    for (int i = 0; i < 10000; i++) {
	      int n = i;
	      for (int j = 3; j >= 0; j--) {
	        num[i][j] = n % 10 | '0';
	        n /= 10;
	      }
	    }
	  }
	} constexpr pre;
	 
	inline void load() {
	  memcpy(ibuf, ibuf + pil, pir - pil);
	  pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);
	  pil = 0;
	  if (pir < SZ) ibuf[pir++] = '\n';
	}
	inline void flush() {
	  fwrite(obuf, 1, por, stdout);
	  por = 0;
	}
	 
	void rd(char &c) {
	  do {
	    if (pil + 1 > pir) load();
	    c = ibuf[pil++];
	  } while (isspace(c));
	}
	 
	void rd(string &x) {
	  x.clear();
	  char c;
	  do {
	    if (pil + 1 > pir) load();
	    c = ibuf[pil++];
	  } while (isspace(c));
	  do {
	    x += c;
	    if (pil == pir) load();
	    c = ibuf[pil++];
	  } while (!isspace(c));
	}
	 
	template <typename T>
	void rd_real(T &x) {
	  string s;
	  rd(s);
	  x = stod(s);
	}
	 
	template <typename T>
	void rd_integer(T &x) {
	  if (pil + 100 > pir) load();
	  char c;
	  do
	    c = ibuf[pil++];
	  while (c < '-');
	  bool minus = 0;
	  if constexpr (is_signed<T>::value || is_same_v<T, __int128>) {
	    if (c == '-') { minus = 1, c = ibuf[pil++]; }
	  }
	  x = 0;
	  while ('0' <= c) { x = x * 10 + (c & 15), c = ibuf[pil++]; }
	  if constexpr (is_signed<T>::value || is_same_v<T, __int128>) {
	    if (minus) x = -x;
	  }
	}
	 
	void rd(int &x) { rd_integer(x); }
	void rd(long long &x) { rd_integer(x); }
	void rd(__int128 &x) { rd_integer(x); }
	void rd(unsigned int &x) { rd_integer(x); }
	void rd(unsigned long long &x) { rd_integer(x); }
	void rd(unsigned __int128 &x) { rd_integer(x); }
	void rd(double &x) { rd_real(x); }
	void rd(long double &x) { rd_real(x); }
	void rd(__float128 &x) { rd_real(x); }
	 
	template <class T, class U>
	void rd(pair<T, U> &p) {
	  return rd(p.first), rd(p.second);
	}
	template <size_t N = 0, typename T>
	void rd_tuple(T &t) {
	  if constexpr (N < std::tuple_size<T>::value) {
	    auto &x = std::get<N>(t);
	    rd(x);
	    rd_tuple<N + 1>(t);
	  }
	}
	template <class... T>
	void rd(tuple<T...> &tpl) {
	  rd_tuple(tpl);
	}
	 
	template <size_t N = 0, typename T>
	void rd(array<T, N> &x) {
	  for (auto &d: x) rd(d);
	}
	template <class T>
	void rd(vector<T> &x) {
	  for (auto &d: x) rd(d);
	}
	 
	void in() {}
	template <class H, class... T>
	void in(H &h, T &... t) {
	  rd(h), in(t...);
	}
	 
	void wt(const char c) {
	  if (por == SZ) flush();
	  obuf[por++] = c;
	}
	void wt(const string s) {
	  for (char c: s) wt(c);
	}
	void wt(const char *s) {
	  size_t len = strlen(s);
	  for (size_t i = 0; i < len; i++) wt(s[i]);
	}
	 
	template <typename T>
	void wt_integer(T x) {
	  if (por > SZ - 100) flush();
	  if (x < 0) { obuf[por++] = '-', x = -x; }
	  int outi;
	  for (outi = 96; x >= 10000; outi -= 4) {
	    memcpy(out + outi, pre.num[x % 10000], 4);
	    x /= 10000;
	  }
	  if (x >= 1000) {
	    memcpy(obuf + por, pre.num[x], 4);
	    por += 4;
	  } else if (x >= 100) {
	    memcpy(obuf + por, pre.num[x] + 1, 3);
	    por += 3;
	  } else if (x >= 10) {
	    int q = (x * 103) >> 10;
	    obuf[por] = q | '0';
	    obuf[por + 1] = (x - q * 10) | '0';
	    por += 2;
	  } else
	    obuf[por++] = x | '0';
	  memcpy(obuf + por, out + outi + 4, 96 - outi);
	  por += 96 - outi;
	}
	template <typename T>
	void wt_real(T x) {
	  ostringstream oss;
	  oss << fixed << setprecision(15) << double(x);
	  string s = oss.str();
	  wt(s);
	}
	 
	inline void wt(int x) { wt_integer(x); }
	inline void wt(long long x) { wt_integer(x); }
	inline void wt(__int128 x) { wt_integer(x); }
	inline void wt(unsigned int x) { wt_integer(x); }
	inline void wt(unsigned long long x) { wt_integer(x); }
	inline void wt(unsigned __int128 x) { wt_integer(x); }
	inline void wt(double x) { wt_real(x); }
	inline void wt(long double x) { wt_real(x); }
	inline void wt(__float128 x) { wt_real(x); }
	 
	template <class T, class U>
	void wt(const pair<T, U> val) {
	  wt(val.first);
	  wt(' ');
	  wt(val.second);
	}
	
	template <size_t N = 0, typename T>
	void wt_tuple(const T t) {
	  if constexpr (N < std::tuple_size<T>::value) {
	    if constexpr (N > 0) { wt(' '); }
	    const auto x = std::get<N>(t);
	    wt(x);
	    wt_tuple<N + 1>(t);
	  }
	}
	template <class... T>
	void wt(tuple<T...> tpl) {
	  wt_tuple(tpl);
	}
	template <class T, size_t S>
	void wt(const array<T, S> val) {
	  auto n = (int)val.size();
	  for (size_t i = 0; i < n; i++) {
	    if (i) wt(' ');
	    wt(val[i]);
	  }
	}
	template <class T>
	void wt(const vector<T> val) {
	  auto n =(int)val.size();
	  for (size_t i = 0; i < n; i++) {
	    if (i) wt(' ');
	    wt(val[i]);
	  }
	}
	void print() { wt('\n'); }
	template <class Head, class... Tail>
	void print(Head &&head, Tail &&... tail) {
	  wt(head);
	  if (sizeof...(Tail)) wt(' ');
	  print(forward<Tail>(tail)...);
	}
	// gcc expansion. called automaticall after main.
	void __attribute__((destructor)) _d() { flush(); }
	} // namespace fastio
	using fastio::in;
	using fastio::print;
	using fastio::flush;
	
	//===================================CODE======================================================
	$1
snippet fastIO20 
	// FastIO c++ 20 onwars has flipao eh?  for more check this blog https://judge.yosupo.jp/submission/21623
	struct IOPre {
	  static constexpr int TEN = 10, SZ = TEN * TEN * TEN * TEN;
	  std::array<char, 4 * SZ> num;
	  constexpr IOPre() : num{} {
	    for (int i = 0; i < SZ; i++) {
	      int n = i;
	      for (int j = 3; j >= 0; j--) {
	        num[i * 4 + j] = static_cast<char>(n % TEN + '0');
	        n /= TEN;
	      }
	    }
	  }
	};
	struct IO {
	#if !HAVE_DECL_FREAD_UNLOCKED
	#define fread_unlocked fread
	#endif
	#if !HAVE_DECL_FWRITE_UNLOCKED
	#define fwrite_unlocked fwrite
	#endif
	  static constexpr int SZ = 1 << 17, LEN = 32, TEN = 10, HUNDRED = TEN * TEN,
	                       THOUSAND = HUNDRED * TEN, TENTHOUSAND = THOUSAND * TEN,
	                       MAGIC_MULTIPLY = 205, MAGIC_SHIFT = 11, MASK = 15,
	                       TWELVE = 12, SIXTEEN = 16;
	  static constexpr IOPre io_pre = {};
	  std::array<char, SZ> input_buffer, output_buffer;
	  int input_ptr_left, input_ptr_right, output_ptr_right;
	 
	  IO()
	      : input_buffer{},
	        output_buffer{},
	        input_ptr_left{},
	        input_ptr_right{},
	        output_ptr_right{} {}
	  IO(const IO&) = delete;
	  IO(IO&&) = delete;
	  IO& operator=(const IO&) = delete;
	  IO& operator=(IO&&) = delete;
	 
	  ~IO() { flush(); }
	 
	  template <class T>
	  struct is_char {
	    static constexpr bool value = std::is_same_v<T, char>;
	  };
	 
	  template <class T>
	  struct is_bool {
	    static constexpr bool value = std::is_same_v<T, bool>;
	  };
	 
	  template <class T>
	  struct is_string {
	    static constexpr bool value =
	        std::is_same_v<T, std::string> || std::is_same_v<T, const char*> ||
	        std::is_same_v<T, char*> || std::is_same_v<std::decay_t<T>, char*>;
	    ;
	  };
	 
	  template <class T, class D = void>
	  struct is_custom {
	    static constexpr bool value = false;
	  };
	 
	  template <class T>
	  struct is_custom<T, std::void_t<typename T::internal_value_type>> {
	    static constexpr bool value = true;
	  };
	 
	  template <class T>
	  struct is_default {
	    static constexpr bool value = is_char<T>::value || is_bool<T>::value ||
	                                  is_string<T>::value || std::is_integral_v<T>;
	  };
	 
	  template <class T, class D = void>
	  struct is_iterable {
	    static constexpr bool value = false;
	  };
	 
	  template <class T>
	  struct is_iterable<
	      T, typename std::void_t<decltype(std::begin(std::declval<T>()))>> {
	    static constexpr bool value = true;
	  };
	 
	  template <class T, class D = void, class E = void>
	  struct is_applyable {
	    static constexpr bool value = false;
	  };
	 
	  template <class T>
	  struct is_applyable<T, std::void_t<typename std::tuple_size<T>::type>,
	                      std::void_t<decltype(std::get<0>(std::declval<T>()))>> {
	    static constexpr bool value = true;
	  };
	 
	  template <class T>
	  static constexpr bool needs_newline = (is_iterable<T>::value ||
	                                         is_applyable<T>::value) &&
	                                        (!is_default<T>::value);
	 
	  template <typename T, typename U>
	  struct any_needs_newline {
	    static constexpr bool value = false;
	  };
	  template <typename T>
	  struct any_needs_newline<T, std::index_sequence<>> {
	    static constexpr bool value = false;
	  };
	  template <typename T, std::size_t I, std::size_t... Is>
	  struct any_needs_newline<T, std::index_sequence<I, Is...>> {
	    static constexpr bool value =
	        needs_newline<decltype(std::get<I>(std::declval<T>()))> ||
	        any_needs_newline<T, std::index_sequence<Is...>>::value;
	  };
	 
	  inline void load() {
	    memcpy(std::begin(input_buffer), std::begin(input_buffer) + input_ptr_left,
	            input_ptr_right - input_ptr_left);
	    input_ptr_right =
	        input_ptr_right - input_ptr_left +
	        static_cast<int>(fread_unlocked(
	            std::begin(input_buffer) + input_ptr_right - input_ptr_left, 1,
	            SZ - input_ptr_right + input_ptr_left, stdin));
	    input_ptr_left = 0;
	  }
	 
	  inline void read_char(char& c) {
	    if (input_ptr_left + LEN > input_ptr_right) load();
	    c = input_buffer[input_ptr_left++];
	  }
	  inline void read_string(std::string& x) {
	    char c;
	    while (read_char(c), c < '!') continue;
	    x = c;
	    while (read_char(c), c >= '!') x += c;
	  }
	  template <class T>
	  inline std::enable_if_t<std::is_integral_v<T>, void> read_int(T& x) {
	    if (input_ptr_left + LEN > input_ptr_right) load();
	    char c = 0;
	    do c = input_buffer[input_ptr_left++];
	    while (c < '-');
	    [[maybe_unused]] bool minus = false;
	    if constexpr (std::is_signed<T>::value == true)
	      if (c == '-') minus = true, c = input_buffer[input_ptr_left++];
	    x = 0;
	    while (c >= '0')
	      x = x * TEN + (c & MASK), c = input_buffer[input_ptr_left++];
	    if constexpr (std::is_signed<T>::value == true)
	      if (minus) x = -x;
	  }
	 
	  inline void skip_space() {
	    if (input_ptr_left + LEN > input_ptr_right) load();
	    while (input_buffer[input_ptr_left] <= ' ') input_ptr_left++;
	  }
	 
	  inline void flush() {
	    fwrite_unlocked(std::begin(output_buffer), 1, output_ptr_right, stdout);
	    output_ptr_right = 0;
	  }
	 
	  inline void write_char(char c) {
	    if (output_ptr_right > SZ - LEN) flush();
	    output_buffer[output_ptr_right++] = c;
	  }
	 
	  inline void write_bool(bool b) {
	    if (output_ptr_right > SZ - LEN) flush();
	    output_buffer[output_ptr_right++] = b ? '1' : '0';
	  }
	 
	  inline void write_string(const std::string& s) {
	    for (auto x : s) write_char(x);
	  }
	 
	  inline void write_string(const char* s) {
	    while (*s) write_char(*s++);
	  }
	 
	  inline void write_string(char* s) {
	    while (*s) write_char(*s++);
	  }
	 
	  template <typename T>
	  inline std::enable_if_t<std::is_integral_v<T>, void> write_int(T x) {
	    if (output_ptr_right > SZ - LEN) flush();
	    if (!x) {
	      output_buffer[output_ptr_right++] = '0';
	      return;
	    }
	    if constexpr (std::is_signed<T>::value == true)
	      if (x < 0) output_buffer[output_ptr_right++] = '-', x = -x;
	    int i = TWELVE;
	    std::array<char, SIXTEEN> buf{};
	    while (x >= TENTHOUSAND) {
	      memcpy(std::begin(buf) + i,
	             std::begin(io_pre.num) + (x % TENTHOUSAND) * 4, 4);
	      x /= TENTHOUSAND;
	      i -= 4;
	    }
	    if (x < HUNDRED) {
	      if (x < TEN) {
	        output_buffer[output_ptr_right++] = static_cast<char>('0' + x);
	      } else {
	        std::uint32_t q =
	            (static_cast<std::uint32_t>(x) * MAGIC_MULTIPLY) >> MAGIC_SHIFT;
	        std::uint32_t r = static_cast<std::uint32_t>(x) - q * TEN;
	        output_buffer[output_ptr_right] = static_cast<char>('0' + q);
	        output_buffer[output_ptr_right + 1] = static_cast<char>('0' + r);
	        output_ptr_right += 2;
	      }
	    } else {
	      if (x < THOUSAND) {
	        memcpy(std::begin(output_buffer) + output_ptr_right,
	               std::begin(io_pre.num) + (x << 2) + 1, 3),
	            output_ptr_right += 3;
	      } else {
	        memcpy(std::begin(output_buffer) + output_ptr_right,
	               std::begin(io_pre.num) + (x << 2), 4),
	            output_ptr_right += 4;
	      }
	    }
	    memcpy(std::begin(output_buffer) + output_ptr_right,
	           std::begin(buf) + i + 4, TWELVE - i);
	    output_ptr_right += TWELVE - i;
	  }
	  template <typename T_>
	  IO& operator<<(T_&& x) {
	    using T =
	        typename std::remove_cv<typename std::remove_reference<T_>::type>::type;
	    static_assert(is_custom<T>::value or is_default<T>::value or
	                  is_iterable<T>::value or is_applyable<T>::value);
	    if constexpr (is_custom<T>::value) {
	      write_int(x.get());
	    } else if constexpr (is_default<T>::value) {
	      if constexpr (is_bool<T>::value) {
	        write_bool(x);
	      } else if constexpr (is_string<T>::value) {
	        write_string(x);
	      } else if constexpr (is_char<T>::value) {
	        write_char(x);
	      } else if constexpr (std::is_integral_v<T>) {
	        write_int(x);
	      }
	    } else if constexpr (is_iterable<T>::value) {
	      // strings are immune
	      using E = decltype(*std::begin(x));
	      constexpr char sep = needs_newline<E> ? '\n' : ' ';
	      int i = 0;
	      for (const auto& y : x) {
	        if (i++) write_char(sep);
	        operator<<(y);
	      }
	    } else if constexpr (is_applyable<T>::value) {
	      // strings are immune
	      constexpr char sep =
	          (any_needs_newline<
	              T, std::make_index_sequence<std::tuple_size_v<T>>>::value)
	              ? '\n'
	              : ' ';
	      int i = 0;
	      std::apply(
	          [this, &sep, &i](auto const&... y) {
	            (((i++ ? write_char(sep) : void()), this->operator<<(y)), ...);
	          },
	          x);
	    }
	    return *this;
	  }
	  template <typename T>
	  IO& operator>>(T& x) {
	    static_assert(is_custom<T>::value or is_default<T>::value or
	                  is_iterable<T>::value or is_applyable<T>::value);
	    static_assert(!is_bool<T>::value);
	    if constexpr (is_custom<T>::value) {
	      typename T::internal_value_type y;
	      read_int(y);
	      x = y;
	    } else if constexpr (is_default<T>::value) {
	      if constexpr (is_string<T>::value) {
	        read_string(x);
	      } else if constexpr (is_char<T>::value) {
	        read_char(x);
	      } else if constexpr (std::is_integral_v<T>) {
	        read_int(x);
	      }
	    } else if constexpr (is_iterable<T>::value) {
	      for (auto& y : x) operator>>(y);
	    } else if constexpr (is_applyable<T>::value) {
	      std::apply([this](auto&... y) { ((this->operator>>(y)), ...); }, x);
	    }
	    return *this;
	  }
	 
	  IO* tie(std::nullptr_t) { return this; }
	  void sync_with_stdio(bool) {}
	};
	 
	namespace std {
	IO io;
	}  // namespace std
	#define cin io
	#define cout io
	$1
#GRAPHS
snippet Dfs 
	const int N=1e5+7;
	vector<int> G[N];
	bool vis[N];
	void Dfs(int v){
		vis[v]=1;
		for(auto &&u:G[v]){
			if(!vis[u]){
				Dfs(u);
			}
		}
	}
snippet Dfs_Lambda 
	vector<vector<int>> G(n+1);
	vector<bool> vis(n+1,0);
	auto Dfs=[&vis,&G](auto&& self,int v)->void{
		vis[v]=1;
		for(auto&& u:G[v]){
			if(!vis[u]){
				self(self,u);
			}
		}
	};
snippet Bfs 
	const int N=1e5+7;
	vector<int> G[N];
	int d[N],p[N];
	bool vis[N];
	template<typename T>
	    void Bfs(T s){
	        deque<T> q;
	        q.emplace_back(s);
	        vis[s]=1;
	        p[s]=-1;
	        while(!q.empty()){
	            T v=q.front();
	            q.pop_front();
	            for(auto u:G[v]){
	                if(!vis[u]){
	                    vis[u]=1;
	                    d[u]=d[v]+1;
	                    p[u]=v;
	                    q.emplace_back(u);
	                }
	            }
	        }
	    }
	/*
	    //imprimir el camino mas corto
	    int s,f; cin>>s>>f;
	    s--,f--;
	    bfs(s);
	    vi a;
	    for(int i=f;i!=-1;i=p[i]) a.emplace_back(i);
	    for(int i=sz(a)-1;~i;--i) cout<<a[i]<<" ";
	*/
snippet Bfs_Lambda 
	V<V<int>> G(n+1);
	V<bool> vis(n+1);
	V<int> p(n+1),d(n+1);
	auto Bfs=[&](int s)->void{
	    queue<int> q;
	    q.emplace(s);
	    vis[s]=1;
	    p[s]=-1;
	    while(!q.empty()){
	        int v=q.front();
	        q.pop();
	        for(auto u:G[v]){
	            if(!vis[u]){
	                vis[u]=1;
	                d[u]=d[v]+1;
	                p[u]=v;
	                q.emplace(u);
	            }
	        }
	    }
	};
snippet Dijkstra
	template<typename T,typename GT>
	pair<V<T>,V<int>> Dijkstra(V<V<pair<GT,GT>>>& G,int s){
	    auto N=(int)G.size();
	    V<T> dist(N,INF<T>);
	    V<int> par(N,-1);
	    priority_queue<pair<T,int>,V<pair<T,int>>, greater<pair<T,int>>> q;
	    dist[s]=0;
	    q.emplace(0,s);
	    while(!q.empty()){
	        auto[dv,v]=q.top();
	        q.pop();
	        if(dv>dist[v]) continue;
	        for(auto u:G[v]){
	            auto [to,cost]=u;
	            if(dist[v]+cost<dist[to]){
	                dist[to]=dist[v]+cost;
	                par[to]=v;
	                q.emplace(dist[to],to);
	            }
	        }      
	    }
	    return{dist,par};
	} 
	V<int> camino(vector<int> &p,int t){
	    V<int> v={t};
	    while (p[v.back()] != -1) v.pb(p[v.back()]);
	    reverse(all(v));
	    return v;
	}
	//declaracion:
	//auto [dist,par]=Dijkstra<type>(G,1);
	//if(dist[n]==INF) -1
	//auto ans=camino(p,n);
#MATH
snippet presum 
	template <typename T, typename U>
	V<T> presum(V<U> &A, bool off = 1) {
	  int N = (int)A.size();
	  V<T> B(N + 1);
	  for(int i=0;i<N;i++) { B[i + 1] = B[i] + A[i]; }
	  if (!off) B.erase(B.begin());
	  return B;
	}
snippet binpow 
	template<typename T>
	T binpow(T a, T b) {
	    T res=1;
	    while(b>0) {
	        if(b&1) res = res * a;
	        a=a*a;
	        b>>=1;
	    }
	    return res;
	}
snippet binpowMOD 
	template<typename T>
	T binpow(T a, T b, T m) {
	    a %= m;
	    T res = 1;
	    while (b > 0) {
	        if (b & 1) res=res*a%m;
	        a = a * a % m;
	        b >>= 1;
	    }
	    return res;
	}
snippet NCK 
	constexpr i32 N=1e6+7; 
	constexpr i64 MOD=1e9+7;
	i32 F[N];
	auto init(){
	    F[0]=1;
	    for(i32 i=1;i<N;i++){
	        F[i]=1LL*F[i-1]*i%MOD;
	    }
	}
	template<typename T>
	T binpow(T a, T b, T m) {
	    a %= m;
	    T res = 1;
	    while (b > 0) {
	        if (b & 1) res=res*a%m;
	        a = a * a % m;
	        b >>= 1;
	    }
	    return res;
	}
	i32 inv(i64 a){
	    return binpow(a,MOD-2,MOD);
	}
	template <typename T>
	i32 nCk(T n, T k){
	    T numerator=F[n];
	    T denominator=1LL*F[k]*F[n-k]%MOD;
	    return 1LL*numerator*inv(denominator)%MOD;
	}
snippet cnt_table 
	//table:
	//decalration -> autp cnt=cnt_table<type>(v,n);
	template<typename A ,typename T>
	V<A> cnt_table(V<T>&v,int n,bool ok=1){
	    V<T> c(ok?n+1:n);
	    for(auto &&x:v){
	        if(!ok) x--;
	        c[x]++;
	    }
	    return c;
	}
	//declaration -> auto cnt=cnt_table(s);
	template<typename A>
	V<A> cnt_table(string&s,bool ok=1){
	    // 0 mayus 1 minus
	    V<A> c(26,0);
	    for(auto &&x:s){
	        ok ? c[x-'a']++ : c[x-'A']++;
	    }
	    return c;
	}
snippet criba 
	const int N=1e6;
	V<int> prime;
	bool vis[N];
	//Criba de Eratosthenes O(N*Log(N))
	void criba(int n) {
		for (int i=2;i<n;++i) {
			if (!vis[i]) prime.emplace_back(i);
			for (int j=2;i*j<n;++j)
				vis[i * j]=1;
		}
	}
	//Criba Lineal O(N);
	void criba_lineal(int n) {
		for (int i = 2; i < n; ++i) {
			if (!vis[i]) prime.push_back (i);
			for (int j = 0; j < prime.size () && i * prime[j] < n; ++j) {
				vis[i * prime[j]] = 1;
				if (i % prime[j] == 0) break;
			}
		}
	}
#DATA_STRUCTURES
snippet DSU 
	struct unionFind {
	  V<int> p;
	  unionFind(int n) : p(n, -1) {} //init 
	  int findParent(int v) {
	    if (p[v] == -1) return v;
	    return p[v] = findParent(p[v]);
	  }
	  bool join(int a, int b) {
	    a = findParent(a);
	    b = findParent(b);
	    if (a == b) return false;
	    p[a] = b;
	    return true;
	  }
	};

snippet Busqueda
	template <class T, class F>
	T find_first(T l, T r, F&& f) {
	    --l,++r;
	    while (r - l > 1) {
	        T m =l+(r-l)/2;
	        if (f(m)) {
	            l = m;
	        } else {
	            r = m;
	        }
	    }
	    return r;
	}
	int bs(const V<int>& a, int x) {
	    auto f = [&](int i)->bool{
	        return a[i] < x;  //lower -> a[i]<x  | upper-> a[i]<=x
	    };
	    int n = (int)a.size();
	    int pos = find_first(0,n-1,f);
	    //if (pos==n||a[pos]!=x) return n;
	    return pos;
	}
snippet FenwickTree "Árbol Binario Indexado"
	template < int N > struct fenwt {
		using F = long long ;
		F a[N + 1];
		void add (int x, F w) {
			for (; x <= N; x += x & -x) a[x] += w;
		}
		F query (int x) {
			F ret = 0;
			for (; x; x -= x & -x) ret += a[x];
			return ret;
		}
		F get (int l, int r) {
			if(l > r) return 0;
			return query (r) - query (l - 1);
		}
	};

snippet sparce_table "tabla dispersa"
	struct SparseTable {
	    int n;
	    vector<vector<int>> st;
	    SparseTable(const vector<int>& arr) {
	        n =(int)arr.size();
	        int logn = 32 - __builtin_clz(n);
	        st.assign(n, vector<int>(logn));
	        for (int i = 0; i < n; i++) {
	            st[i][0] = arr[i];
	        }
	        for (int j = 1; (1 << j) <= n; j++) {
	            for (int i = 0; i + (1 << j) <= n; i++) {
	                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
	            }
	        }
	    }
	    int query(int l, int r) {
	        int j = 31 - __builtin_clz(r - l + 1);
	        return min(st[l][j], st[r - (1 << j) + 1][j]);
	    }
	};

snippet SegmentTreeRecursive "Recursivo" 
	const int N=1e5+7;
	struct STree{
	    int T[4*N];
	    void modify(int n){
	    }
	    void init(const vector<int> &a,int n,int L,int R){
	        if(L==R){
	            T[n]=a[L];
	            return;
	        }
	        int M=(L+R)>>1;
	        int x=n<<1;
	        init(a,x,L,M); 
	        init(a,x|1,M+1,R);
	        modify(n);
	    }
	    void update(int n,int L,int R,int I,int val){
	        if(L==R){
	            T[n]=val;
	            return;
	        }
	        int M=(L+R)>>1;
	        int x=n<<1;
	        if(I<=M) update(x,L,M,I,val);
	        else update(x|1,M+1,R,I,val);
	        modify(n);
	    }
        int get(int i, int L, int R, int u, int v) { // (1,rango total ,L ,R)
        	if (L > v || R < u) return -INF<int>; //fuera de rango
        	if (L >= u && R <= v) return T[i];  //en rango 
        	int mid = (L + R) >> 1;
        	int left= get(i << 1, L, mid, u, v);
        	int right = get(i << 1 | 1, mid + 1, R, u, v);
        	return max<ll>(left, right);
    	}
	};
snippet LazySegmentTree "Lazy"
	template<class Info, class Tag>
		struct LazySegmentTree {
		    int n;
		    std::vector<Info> info;
		    std::vector<Tag> tag;
		    LazySegmentTree() : n(0) {}
		    LazySegmentTree(int n_, Info v_ = Info()) {
		    	init(n_, v_);
		    }
		    template<class T>
		    LazySegmentTree(std::vector<T> init_) {
		        init(init_);
		    }
		    void init(int n_, Info v_ = Info()) {
		        init(std::vector(n_, v_));
		    }
		    template<class T>
		    void init(std::vector<T> init_) {
		        n = init_.size();
		        info.assign(4 << std::__lg(n), Info());
		        tag.assign(4 << std::__lg(n), Tag());
		        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
		            if (r - l == 1) {
		                info[p] = init_[l];
		                return;
		            }
		            int m = (l + r) / 2;
		            build(2 * p, l, m);
		            build(2 * p + 1, m, r);
		            pull(p);
		        };
		        build(1, 0, n);
		    }
		    void pull(int p) {
		        info[p] = info[2 * p] + info[2 * p + 1];
		    }
		    void apply(int p, const Tag &v) {
		        info[p].apply(v);
		        tag[p].apply(v);
		    }
		    void push(int p) {
		        apply(2 * p, tag[p]);
		        apply(2 * p + 1, tag[p]);
		        tag[p] = Tag();
		    }
		    void modify(int p, int l, int r, int x, const Info &v) {
		        if (r - l == 1) {
		            info[p] = v;
		            return;
		        }
		        int m = (l + r) / 2;
		        push(p);
		        if (x < m) {
		            modify(2 * p, l, m, x, v);
		        } else {
		            modify(2 * p + 1, m, r, x, v);
		        }
		        pull(p);
		    }
		    void modify(int p, const Info &v) {
		        modify(1, 0, n, p, v);
		    }
		    Info rangeQuery(int p, int l, int r, int x, int y) {
		        if (l >= y || r <= x) {
		            return Info();
		        }
		        if (l >= x && r <= y) {
		            return info[p];
		        }
		        int m = (l + r) / 2;
		        push(p);
		        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
		    }
		    Info rangeQuery(int l, int r) {
		        return rangeQuery(1, 0, n, l, r);
		    }
		    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {
		        if (l >= y || r <= x) {
		            return;
		        }
		        if (l >= x && r <= y) {
		            apply(p, v);
		            return;
		        }
		        int m = (l + r) / 2;
		        push(p);
		        rangeApply(2 * p, l, m, x, y, v);
		        rangeApply(2 * p + 1, m, r, x, y, v);
		        pull(p);
		    }
		    void rangeApply(int l, int r, const Tag &v) {
		        return rangeApply(1, 0, n, l, r, v);
		    }
		    template<class F>
		    int findFirst(int p, int l, int r, int x, int y, F &&pred) {
		        if (l >= y || r <= x) {
		            return -1;
		        }
		        if (l >= x && r <= y && !pred(info[p])) {
		            return -1;
		        }
		        if (r - l == 1) {
		            return l;
		        }
		        int m = (l + r) / 2;
		        push(p);
		        int res = findFirst(2 * p, l, m, x, y, pred);
		        if (res == -1) {
		            res = findFirst(2 * p + 1, m, r, x, y, pred);
		        }
		        return res;
		    }
		    template<class F>
		    int findFirst(int l, int r, F &&pred) {
		        return findFirst(1, 0, n, l, r, pred);
		    }
		    template<class F>
		    int findLast(int p, int l, int r, int x, int y, F &&pred) {
		        if (l >= y || r <= x) {
		            return -1;
		        }
		        if (l >= x && r <= y && !pred(info[p])) {
		            return -1;
		        }
		        if (r - l == 1) {
		            return l;
		        }
		        int m = (l + r) / 2;
		        push(p);
		        int res = findLast(2 * p + 1, m, r, x, y, pred);
		        if (res == -1) {
		            res = findLast(2 * p, l, m, x, y, pred);
		        }
		        return res;
		    }
		    template<class F>
		    int findLast(int l, int r, F &&pred) {
		        return findLast(1, 0, n, l, r, pred);
		    }
		};
#STRINGS
snippet Sepstring "separa un getline y vol convierte en V<string>"
	inline vector<string> sepstring(const string &s){
    	stringstream ss(s);
    	string tmp;
    	V<string> text;
    	while(ss>>tmp){
    	    text.emplace_back(tmp);
    	}
    	return text;
	}
snippet z_funtion "funcion Z"
	vector<int> z_function(string s) {
	    int n = s.size();
	    vector<int> z(n);
	    int l = 0, r = 0;
	    for(int i = 1; i < n; i++) {
	        if(i < r) {
	            z[i] = min(r - i, z[i - l]);
	        }
	        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {
	            z[i]++;
	        }
	        if(i + z[i] > r) {
	            l = i;
	            r = i + z[i];
	        }
	    }
	    return z;
	}

snippet kmp "Prefix function - Knuth-Morris-Pratt"
	vector<int> kmp(string T, string P) {
		int n = T.size(), m = P.size();
		vector<int> b(m + 1),ans; 
		b[0] = -1;
		// Preprocess P
		int i = 0, j = -1;
		while (i < m) {
			while (j >= 0 && P[i] != P[j]) j = b[j];
			i++; j++;
			b[i] = j;
		}
		// Search T
		i = 0, j = 0;
		while (i < n) {
			while (j >= 0 && T[i] != P[j]) j = b[j];
			i++; j++;
			if (j == m) {
				//cout << "P is found at index " << i - j << endl;
    	        ans.emplace_back((i-j));
				j = b[j];
			}
		}
		return ans;
	}
